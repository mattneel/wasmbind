const std = @import("std");
const types = @import("types.zig");

pub const CodegenOptions = struct {
    module_name: []const u8 = "bindings",
    debug: bool = false,
};

pub const CodegenResult = struct {
    source: []const u8,
    allocator: std.mem.Allocator,

    pub fn deinit(self: *CodegenResult) void {
        self.allocator.free(self.source);
    }
};

pub fn generateBindings(
    allocator: std.mem.Allocator,
    comptime exports_decl: anytype,
    options: CodegenOptions,
) !CodegenResult {
    _ = options;

    var buffer = std.ArrayListUnmanaged(u8){};
    errdefer buffer.deinit(allocator);

    var writer = buffer.writer(allocator);

    try writer.writeAll(
        \\// Auto-generated by wasmbind - DO NOT EDIT
        \\// TypeScript bindings for WASM module
        \\
        \\
    );

    try writer.writeAll(
        \\type WasmbindTypedArray =
        \\  Int8Array |
        \\  Uint8Array |
        \\  Uint8ClampedArray |
        \\  Int16Array |
        \\  Uint16Array |
        \\  Int32Array |
        \\  Uint32Array |
        \\  Float32Array |
        \\  Float64Array |
        \\  BigInt64Array |
        \\  BigUint64Array;
        \\
        \\type WasmbindSliceBuffer = {
        \\  ptr: number;
        \\  len: number;
        \\  byteLength: number;
        \\};
        \\
        \\const wasmbindTextEncoder = new TextEncoder();
        \\const wasmbindTextDecoder = new TextDecoder();
        \\
        \\
    );

    var type_names = std.ArrayListUnmanaged([]const u8){};
    defer {
        for (type_names.items) |name| allocator.free(name);
        type_names.deinit(allocator);
    }

    const exports_info = @typeInfo(@TypeOf(exports_decl));
    if (exports_info != .@"struct") {
        @compileError("exports must be a struct literal");
    }

    inline for (exports_info.@"struct".fields) |field| {
        const export_value = @field(exports_decl, field.name);
        const export_type = @TypeOf(export_value);

        switch (@typeInfo(export_type)) {
            .type => {
                const exported_type = export_value;
                if (@typeInfo(exported_type) != .@"struct") break;

                try generateStructInterface(writer, field.name, exported_type);

                if (hasPublicMethods(exported_type)) {
                    try generateClass(writer, field.name, exported_type);
                    try type_names.append(allocator, try allocator.dupe(u8, field.name));
                }
            },
            else => {},
        }
    }

    try generateLoadWasm(writer);

    return .{
        .source = try buffer.toOwnedSlice(allocator),
        .allocator = allocator,
    };
}

fn hasPublicMethods(comptime T: type) bool {
    const info = @typeInfo(T);
    if (info != .@"struct") return false;

    inline for (info.@"struct".decls) |decl| {
        if (@typeInfo(@TypeOf(@field(T, decl.name))) == .@"fn") return true;
    }

    return false;
}

fn generateStructInterface(
    writer: anytype,
    comptime type_name: []const u8,
    comptime T: type,
) !void {
    const fields = types.introspectStruct(T);

    try writer.print("export interface {s} {{\n", .{type_name});

    inline for (fields) |field| {
        try writer.print("  {s}: ", .{field.name});
        try writeTsType(writer, field.ts_type);
        try writer.writeAll(";\n");
    }

    try writer.writeAll("}\n\n");
}

fn generateClass(
    writer: anytype,
    comptime type_name: []const u8,
    comptime T: type,
) !void {
    try writer.print(
        \\export class {s} {{
        \\  private wasm: WebAssembly.Instance;
        \\  private memory: WebAssembly.Memory;
        \\  private id: number;
        \\
        \\
    , .{type_name});

    try writer.writeAll(
        \\  private marshalString(value: string): WasmbindSliceBuffer {
        \\    const bytes = wasmbindTextEncoder.encode(value);
        \\    const ptr = (this.wasm.exports.allocate as Function)(bytes.length);
        \\    new Uint8Array(this.memory.buffer, ptr, bytes.length).set(bytes);
        \\    return { ptr, len: bytes.length, byteLength: bytes.length };
        \\  }
        \\
        \\  private marshalTypedArray(view: WasmbindTypedArray): WasmbindSliceBuffer {
        \\    const bytes = new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
        \\    const ptr = (this.wasm.exports.allocate as Function)(bytes.length);
        \\    new Uint8Array(this.memory.buffer, ptr, bytes.length).set(bytes);
        \\    return { ptr, len: view.length, byteLength: bytes.length };
        \\  }
        \\
        \\  private freeBuffer(buf: WasmbindSliceBuffer): void {
        \\    (this.wasm.exports.deallocate as Function)(buf.ptr, buf.byteLength);
        \\  }
        \\
        \\
    );

    if (@hasDecl(T, "init")) {
        const init_sig = types.introspectFunction(@field(T, "init"));

        try writer.writeAll("  constructor(wasm: WebAssembly.Instance");
        inline for (init_sig.params) |param| {
            try writer.print(", {s}: ", .{param.name});
            try writeTsType(writer, param.ts_type);
        }
        try writer.writeAll(") {\n");
        try writer.writeAll(
            \\    this.wasm = wasm;
            \\    this.memory = wasm.exports.memory as WebAssembly.Memory;
            \\
        );

        try writer.print("    this.id = (wasm.exports.{s}_init as Function)(", .{type_name});
        inline for (init_sig.params, 0..) |param, idx| {
            if (idx > 0) try writer.writeAll(", ");
            try writer.print("{s}", .{param.name});
        }
        try writer.writeAll(");\n");
        try writer.writeAll("  }\n\n");
    } else {
        try writer.writeAll(
            \\  constructor(wasm: WebAssembly.Instance, id: number) {
            \\    this.wasm = wasm;
            \\    this.memory = wasm.exports.memory as WebAssembly.Memory;
            \\    this.id = id;
            \\  }
            \\
            \\
        );
    }

    const struct_info = @typeInfo(T).@"struct";
    inline for (struct_info.decls) |decl| {
        if (comptime std.mem.eql(u8, decl.name, "init")) continue;
        if (comptime std.mem.eql(u8, decl.name, "deinit")) continue;

        const decl_value = @field(T, decl.name);
        if (@typeInfo(@TypeOf(decl_value)) == .@"fn") {
            try generateMethod(writer, type_name, decl.name, decl_value);
        }
    }

    if (@hasDecl(T, "deinit")) {
        try writer.print(
            \\  destroy(): void {{
            \\    (this.wasm.exports.{s}_deinit as Function)(this.id);
            \\  }}
            \\
            \\
        , .{type_name});
    }

    try writer.writeAll("}\n\n");
}

fn generateMethod(
    writer: anytype,
    comptime type_name: []const u8,
    comptime method_name: []const u8,
    comptime method: anytype,
) !void {
    const sig = comptime types.introspectFunction(method);
    const start_idx: usize = if (sig.params.len > 0 and
        @typeInfo(sig.params[0].original_type) == .pointer) 1 else 0;
    const has_slice_return = isSliceType(sig.return_type_original);
    const has_buffers = comptime methodHasBufferParams(sig, start_idx);

    try writer.print("  {s}(", .{method_name});
    inline for (sig.params[start_idx..], 0..) |param, idx| {
        if (idx > 0) try writer.writeAll(", ");
        try writer.print("{s}: ", .{param.name});
        try writeTsType(writer, param.ts_type);
    }
    try writer.writeAll("): ");
    try writeTsType(writer, sig.return_type);
    try writer.writeAll(" {\n");

    if (has_buffers) {
        inline for (sig.params, 0..) |param, idx| {
            if (idx < start_idx) continue;
            switch (param.ts_type) {
                .string => try writer.print("    const {s}_buf = this.marshalString({s});\n", .{ param.name, param.name }),
                .slice => try writer.print("    const {s}_buf = this.marshalTypedArray({s});\n", .{ param.name, param.name }),
                else => {},
            }
        }
        try writer.writeAll("    try {\n");
        try emitTsCallBody(writer, type_name, method_name, sig, start_idx, "      ", has_slice_return);
        try writer.writeAll("    } finally {\n");
        inline for (sig.params, 0..) |param, idx| {
            if (idx < start_idx) continue;
            switch (param.ts_type) {
                .string, .slice => try writer.print("      this.freeBuffer({s}_buf);\n", .{param.name}),
                else => {},
            }
        }
        try writer.writeAll("    }\n");
    } else {
        try emitTsCallBody(writer, type_name, method_name, sig, start_idx, "    ", has_slice_return);
    }

    try writer.writeAll("  }\n\n");
}

fn generateLoadWasm(writer: anytype) !void {
    try writer.writeAll(
        \\export async function loadWasm(wasmPath: string): Promise<WebAssembly.Instance> {
        \\  const response = await fetch(wasmPath);
        \\  const bytes = await response.arrayBuffer();
        \\  const { instance } = await WebAssembly.instantiate(bytes, {});
        \\  (instance.exports.__wasmbind_init as Function)();
        \\  return instance;
        \\}
        \\
    );
}

fn writeTsType(writer: anytype, ts_type: types.TsType) !void {
    switch (ts_type) {
        .primitive => |prim| switch (prim) {
            .number => try writer.writeAll("number"),
            .bigint => try writer.writeAll("bigint"),
            .boolean => try writer.writeAll("boolean"),
            .void => try writer.writeAll("void"),
        },
        .string => try writer.writeAll("string"),
        .slice => |_| {
            try writer.writeAll(types.toTsString(ts_type));
        },
        .@"struct" => |info| {
            const name = shortTypeName(info.name);
            try writer.writeAll(name);
        },
        .pointer => @compileError("Pointer types are not yet supported in TypeScript codegen"),
    }
}

fn shortTypeName(full: []const u8) []const u8 {
    if (std.mem.lastIndexOfScalar(u8, full, '.')) |idx| {
        return full[idx + 1 ..];
    }
    return full;
}

inline fn methodHasBufferParams(
    comptime sig: types.FunctionSignature,
    start_idx: usize,
) bool {
    inline for (sig.params, 0..) |param, idx| {
        if (idx < start_idx) continue;
        if (tsParamRequiresBuffer(param)) return true;
    }
    return false;
}

inline fn tsParamRequiresBuffer(comptime param: types.FunctionParam) bool {
    return switch (param.ts_type) {
        .string => true,
        .slice => true,
        else => false,
    };
}

inline fn isSliceType(comptime T: type) bool {
    return switch (@typeInfo(T)) {
        .pointer => |ptr_info| ptr_info.size == .slice,
        else => false,
    };
}

inline fn emitTsCallBody(
    writer: anytype,
    comptime type_name: []const u8,
    comptime method_name: []const u8,
    comptime sig: types.FunctionSignature,
    start_idx: usize,
    indent: []const u8,
    is_slice_return: bool,
) !void {
    if (is_slice_return) {
        const ptr_export = std.fmt.comptimePrint("{s}_{s}_ptr", .{ type_name, method_name });
        const len_export = std.fmt.comptimePrint("{s}_{s}_len", .{ type_name, method_name });

        try writer.print(
            "{s}const ptr = (this.wasm.exports.{s} as Function)(this.id",
            .{ indent, ptr_export },
        );
        try emitTsCallArguments(writer, sig, start_idx);
        try writer.writeAll(");\n");

        try writer.print(
            "{s}const len = (this.wasm.exports.{s} as Function)(this.id",
            .{ indent, len_export },
        );
        try emitTsCallArguments(writer, sig, start_idx);
        try writer.writeAll(");\n");

        switch (sig.return_type) {
            .string => {
                try writer.print(
                    "{s}const bytes = new Uint8Array(this.memory.buffer, ptr, len);\n",
                    .{indent},
                );
                try writer.print(
                    "{s}return wasmbindTextDecoder.decode(bytes);\n",
                    .{indent},
                );
            },
            .slice => |info| {
                _ = info;
                const array_type = types.toTsString(sig.return_type);
                try writer.print(
                    "{s}return new {s}(this.memory.buffer, ptr, len);\n",
                    .{ indent, array_type },
                );
            },
            else => @compileError("slice return expected string or slice TsType"),
        }
        return;
    }

    if (sig.return_type_original != void) {
        try writer.print("{s}const result = ", .{indent});
    } else {
        try writer.writeAll(indent);
    }

    try writer.print(
        "(this.wasm.exports.{s}_{s} as Function)(this.id",
        .{ type_name, method_name },
    );
    try emitTsCallArguments(writer, sig, start_idx);
    try writer.writeAll(");\n");

    if (sig.return_type_original != void) {
        try writer.print("{s}return result;\n", .{indent});
    }
}

inline fn emitTsCallArguments(
    writer: anytype,
    comptime sig: types.FunctionSignature,
    start_idx: usize,
) !void {
    inline for (sig.params, 0..) |param, idx| {
        if (idx < start_idx) continue;
        switch (param.ts_type) {
            .string, .slice => try writer.print(", {s}_buf.ptr, {s}_buf.len", .{ param.name, param.name }),
            else => try writer.print(", {s}", .{param.name}),
        }
    }
}
