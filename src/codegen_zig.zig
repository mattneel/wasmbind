const std = @import("std");
const types = @import("types.zig");
const builtin = std.builtin;

pub const CodegenOptions = struct {
    module_name: []const u8 = "exports",
    debug: bool = false,
};

pub const CodegenResult = struct {
    source: []const u8,
    exports: []const []const u8,
    allocator: std.mem.Allocator,

    pub fn deinit(self: *CodegenResult) void {
        self.allocator.free(self.source);
        for (self.exports) |name| {
            self.allocator.free(name);
        }
        self.allocator.free(self.exports);
    }
};

const ExportContext = struct {
    allocator: std.mem.Allocator,
    type_names: std.ArrayListUnmanaged([]const u8),

    fn init(allocator: std.mem.Allocator) ExportContext {
        return .{ .allocator = allocator, .type_names = .{} };
    }

    fn deinit(self: *ExportContext) void {
        for (self.type_names.items) |name| {
            self.allocator.free(name);
        }
        self.type_names.deinit(self.allocator);
    }

    fn addType(self: *ExportContext, comptime name: []const u8) !void {
        const copy = try self.allocator.dupe(u8, name);
        try self.type_names.append(self.allocator, copy);
    }
};

pub fn generateExports(
    allocator: std.mem.Allocator,
    comptime exports_decl: anytype,
    options: CodegenOptions,
) !CodegenResult {
    _ = options;

    var source = std.ArrayListUnmanaged(u8){};
    errdefer source.deinit(allocator);

    var writer = source.writer(allocator);

    try writer.writeAll(
        \\// Auto-generated by wasmbind - DO NOT EDIT
        \\// Generated from wasm.zig exports declaration
        \\
        \\const std = @import("std");
        \\const wasm_contract = @import("wasm_contract");
        \\const wasm_exports = wasm_contract.exports;
        \\
        \\// Global allocator for WASM module
        \\const allocator = std.heap.wasm_allocator;
        \\
        \\
    );

    const exports_type_info = @typeInfo(@TypeOf(exports_decl));
    if (exports_type_info != .@"struct") {
        @compileError("exports declaration must be a struct literal");
    }

    var export_names = std.ArrayListUnmanaged([]const u8){};
    errdefer {
        for (export_names.items) |name| allocator.free(name);
        export_names.deinit(allocator);
    }

    var context = ExportContext.init(allocator);
    defer context.deinit();

    inline for (exports_type_info.@"struct".fields) |field| {
        const export_value = @field(exports_decl, field.name);
        const export_type = @TypeOf(export_value);
        switch (@typeInfo(export_type)) {
            .type => try generateTypeExports(
                writer,
                field.name,
                export_value,
                allocator,
                &export_names,
                &context,
                exports_decl,
            ),
            .@"fn" => try generateFunctionExport(
                writer,
                field.name,
                export_value,
                allocator,
                &export_names,
                exports_decl,
            ),
            else => @compileError("Unsupported export entry: " ++ @typeName(export_type)),
        }
    }

    try generateLifecycle(writer, allocator, &context, &export_names);

    const source_slice = try source.toOwnedSlice(allocator);
    const export_slice = try export_names.toOwnedSlice(allocator);

    return .{
        .source = source_slice,
        .exports = export_slice,
        .allocator = allocator,
    };
}

fn generateTypeExports(
    writer: anytype,
    comptime export_name: []const u8,
    comptime T: type,
    allocator: std.mem.Allocator,
    export_names: *std.ArrayListUnmanaged([]const u8),
    context: *ExportContext,
    comptime exports_decl: anytype,
) !void {
    const type_info = @typeInfo(T);
    switch (type_info) {
        .@"struct" => |struct_info| {
            if (struct_info.layout != .@"extern") {
                @compileError("Type " ++ @typeName(T) ++ " must be an extern struct");
            }

            try context.addType(export_name);

            try writer.print("const {s} = wasm_exports.{s};\n", .{ export_name, export_name });
            try writer.print(
                \\// ============================================================
                \\// Exports for {s}
                \\// ============================================================
                \\
                \\const {s}_Type = {s};
                \\
                \\var {s}_instances: std.ArrayListUnmanaged(*{s}_Type) = .{{}};
                \\var {s}_next_id: u32 = 0;
                \\
                \\
            , .{ export_name, export_name, export_name, export_name, export_name, export_name });

            inline for (struct_info.decls) |decl| {
                const decl_value = @field(T, decl.name);
                const decl_type_info = @typeInfo(@TypeOf(decl_value));
                if (decl_type_info == .@"fn") {
                    try generateMethodExport(
                        writer,
                        export_name,
                        T,
                        decl.name,
                        decl_value,
                        allocator,
                        export_names,
                        exports_decl,
                    );
                }
            }
        },
        else => @compileError("Only struct types can be exported, got " ++ @typeName(T)),
    }
}

fn generateMethodExport(
    writer: anytype,
    comptime struct_name: []const u8,
    comptime struct_type: type,
    comptime method_name: []const u8,
    comptime method: anytype,
    allocator: std.mem.Allocator,
    export_names: *std.ArrayListUnmanaged([]const u8),
    comptime exports_decl: anytype,
) !void {
    const sig = comptime types.introspectFunction(method);

    if (isSliceType(sig.return_type_original)) {
        try generateSliceReturnExports(
            writer,
            struct_name,
            method_name,
            struct_type,
            sig,
            allocator,
            export_names,
            exports_decl,
        );
        return;
    }

    const export_fn_name = try std.fmt.allocPrint(
        allocator,
        "{s}_{s}",
        .{ struct_name, method_name },
    );
    try export_names.append(allocator, export_fn_name);

    if (std.mem.eql(u8, method_name, "init")) {
        try generateInitMethod(writer, export_fn_name, struct_name, method, exports_decl);
        return;
    }

    try generateRegularMethod(
        writer,
        export_fn_name,
        struct_name,
        struct_type,
        method_name,
        sig,
        exports_decl,
    );
}

fn generateInitMethod(
    writer: anytype,
    export_fn_name: []const u8,
    comptime type_name: []const u8,
    comptime method: anytype,
    comptime exports_decl: anytype,
) !void {
    const sig = comptime types.introspectFunction(method);
    try writer.print("export fn {s}(", .{export_fn_name});

    inline for (sig.params, 0..) |param, idx| {
        if (idx > 0) try writer.writeAll(", ");
        try writer.print("{s}: ", .{param.name});
        try writeZigType(writer, param.original_type, exports_decl);
    }

    try writer.writeAll(") u32 {\n");

    try writer.print(
        \\    const instance = allocator.create({s}_Type) catch unreachable;
        \\    instance.* = {s}_Type.init(
    , .{ type_name, type_name });

    inline for (sig.params, 0..) |param, idx| {
        if (idx > 0) try writer.writeAll(", ");
        try writer.print("{s}", .{param.name});
    }

    try writer.print(
        \\);
        \\    {s}_instances.append(allocator, instance) catch unreachable;
        \\    const id = {s}_next_id;
        \\    {s}_next_id += 1;
        \\    return id;
        \\}}
    , .{ type_name, type_name, type_name });
    try writer.writeAll("\n\n");
}

inline fn generateRegularMethod(
    writer: anytype,
    export_fn_name: []const u8,
    comptime type_name: []const u8,
    comptime struct_type: type,
    comptime method_name: []const u8,
    comptime sig: types.FunctionSignature,
    comptime exports_decl: anytype,
) !void {
    const start_idx: usize = comptime methodSelfOffset(sig, struct_type);

    try writer.print("export fn {s}(id: u32", .{export_fn_name});
    try emitParameterSignature(writer, sig, start_idx, exports_decl);

    try writer.writeAll(") ");
    try writeZigType(writer, sig.return_type_original, exports_decl);
    try writer.writeAll(" {\n");

    try writer.print(
        \\    if (id >= {s}_instances.items.len) {{
        \\        @panic("Invalid {s} instance ID");
        \\    }}
        \\
        \\    const instance = {s}_instances.items[id];
        \\
    , .{ type_name, type_name, type_name });

    try emitSliceParamReconstruction(writer, sig, start_idx, exports_decl);

    if (sig.return_type_original != void) {
        try writer.writeAll("    return ");
    } else {
        try writer.writeAll("    ");
    }

    try writer.print("instance.{s}(", .{method_name});

    var wrote_arg = false;
    inline for (sig.params, 0..) |param, idx| {
        if (idx >= start_idx) {
            if (wrote_arg) try writer.writeAll(", ");
            try writer.print("{s}", .{param.name});
            wrote_arg = true;
        }
    }

    try writer.writeAll(");\n}\n\n");
}

inline fn generateSliceReturnExports(
    writer: anytype,
    comptime type_name: []const u8,
    comptime method_name: []const u8,
    comptime struct_type: type,
    comptime sig: types.FunctionSignature,
    allocator: std.mem.Allocator,
    export_names: *std.ArrayListUnmanaged([]const u8),
    comptime exports_decl: anytype,
) !void {
    const ptr_export = try std.fmt.allocPrint(
        allocator,
        "{s}_{s}_ptr",
        .{ type_name, method_name },
    );
    try export_names.append(allocator, ptr_export);

    const len_export = try std.fmt.allocPrint(
        allocator,
        "{s}_{s}_len",
        .{ type_name, method_name },
    );
    try export_names.append(allocator, len_export);

    try writer.print(
        "var {s}_{s}_last_ptr: usize = 0;\n",
        .{ type_name, method_name },
    );
    try writer.print(
        "var {s}_{s}_last_len: usize = 0;\n\n",
        .{ type_name, method_name },
    );

    const start_idx: usize = comptime methodSelfOffset(sig, struct_type);

    try writer.print("export fn {s}(id: u32", .{ptr_export});
    try emitParameterSignature(writer, sig, start_idx, exports_decl);
    try writer.writeAll(") usize {\n");

    try writer.print(
        \\    if (id >= {s}_instances.items.len) {{
        \\        @panic("Invalid {s} instance ID");
        \\    }}
        \\
        \\    const instance = {s}_instances.items[id];
        \\
    , .{ type_name, type_name, type_name });

    try emitSliceParamReconstruction(writer, sig, start_idx, exports_decl);

    try writer.print("    const data = instance.{s}(", .{method_name});

    var wrote_arg = false;
    inline for (sig.params, 0..) |param, idx| {
        if (idx < start_idx) continue;
        if (wrote_arg) try writer.writeAll(", ");
        try writer.print("{s}", .{param.name});
        wrote_arg = true;
    }

    try writer.writeAll(");\n");
    try writer.print(
        \\    {s}_{s}_last_ptr = @intFromPtr(data.ptr);
        \\    {s}_{s}_last_len = data.len;
        \\    return {s}_{s}_last_ptr;
        \\}}
        \\
    , .{ type_name, method_name, type_name, method_name, type_name, method_name });

    try writer.print("export fn {s}(id: u32) usize ", .{len_export});
    try writer.writeAll("{\n");
    try writer.writeAll("    _ = id;\n");
    try writer.print(
        "    return {s}_{s}_last_len;\n",
        .{ type_name, method_name },
    );
    try writer.writeAll("}\n\n");
}

fn generateFunctionExport(
    writer: anytype,
    comptime export_name: []const u8,
    comptime func: anytype,
    allocator: std.mem.Allocator,
    export_names: *std.ArrayListUnmanaged([]const u8),
    comptime exports_decl: anytype,
) !void {
    const sig = comptime types.introspectFunction(func);
    try export_names.append(allocator, try allocator.dupe(u8, export_name));

    try writer.print("export fn {s}(", .{export_name});

    inline for (sig.params, 0..) |param, idx| {
        if (idx > 0) try writer.writeAll(", ");
        try writer.print("{s}: ", .{param.name});
        try writeZigType(writer, param.original_type, exports_decl);
    }

    try writer.writeAll(") ");
    try writeZigType(writer, sig.return_type_original, exports_decl);
    try writer.writeAll(" {\n");

    if (sig.return_type_original != void) {
        try writer.writeAll("    return ");
    } else {
        try writer.writeAll("    ");
    }

    try writer.print("{s}(", .{export_name});

    inline for (sig.params, 0..) |param, idx| {
        if (idx > 0) try writer.writeAll(", ");
        try writer.print("{s}", .{param.name});
    }

    try writer.writeAll(");\n}\n\n");
}

fn generateLifecycle(
    writer: anytype,
    allocator: std.mem.Allocator,
    context: *ExportContext,
    export_names: *std.ArrayListUnmanaged([]const u8),
) !void {
    try writer.writeAll(
        \\// ============================================================
        \\// Module Lifecycle
        \\// ============================================================
        \\
        \\export fn __wasmbind_init() void {
    );

    for (context.type_names.items) |type_name| {
        try writer.print(
            \\    {s}_instances = .{{}};
            \\    {s}_next_id = 0;
            \\
        , .{ type_name, type_name });
    }

    try writer.writeAll(
        \\}
        \\
        \\export fn __wasmbind_deinit() void {
        \\
    );

    for (context.type_names.items) |type_name| {
        try writer.print(
            \\    for ({s}_instances.items) |instance| {{
            \\        if (@hasDecl({s}_Type, "deinit")) {{
            \\            instance.deinit();
            \\        }}
            \\        allocator.destroy(instance);
            \\    }}
            \\    {s}_instances.deinit(allocator);
            \\    {s}_instances = .{{}};
            \\    {s}_next_id = 0;
            \\
        , .{ type_name, type_name, type_name, type_name, type_name });
    }

    try writer.writeAll("}\n\n");

    try export_names.append(allocator, try allocator.dupe(u8, "__wasmbind_init"));
    try export_names.append(allocator, try allocator.dupe(u8, "__wasmbind_deinit"));

    try writer.writeAll(
        \\pub fn allocate(size: usize) usize {
        \\    const buffer = allocator.alloc(u8, size) catch @panic("wasmbind: allocation failed");
        \\    return @intFromPtr(buffer.ptr);
        \\}
        \\
        \\pub fn deallocate(ptr_value: usize, size: usize) void {
        \\    const ptr = @as([*]u8, @ptrFromInt(ptr_value));
        \\    allocator.free(ptr[0..size]);
        \\}
        \\
    );
    try export_names.append(allocator, try allocator.dupe(u8, "allocate"));
    try export_names.append(allocator, try allocator.dupe(u8, "deallocate"));
}

fn writeZigType(writer: anytype, comptime T: type, comptime exports_decl: anytype) !void {
    const info = @typeInfo(T);
    switch (info) {
        .pointer => |ptr| try writePointerType(writer, ptr, exports_decl),
        .array => |arr| {
            try writer.print("[{d}]", .{arr.len});
            try writeZigType(writer, arr.child, exports_decl);
        },
        .@"struct" => |struct_info| {
            if (struct_info.layout == .@"extern") {
                if (exportFieldNameForType(exports_decl, T)) |name| {
                    try writer.writeAll(name);
                    return;
                }
            }
            try writer.writeAll(@typeName(T));
        },
        else => try writer.writeAll(@typeName(T)),
    }
}

fn writePointerType(
    writer: anytype,
    comptime ptr: builtin.Type.Pointer,
    comptime exports_decl: anytype,
) !void {
    const prefix = switch (ptr.size) {
        .one => "*",
        .many => "[*]",
        .slice => "[]",
        .c => "[*c]",
    };
    try writer.writeAll(prefix);

    if (ptr.alignment != 0) {
        try writer.print("align({d}) ", .{ptr.alignment});
    }

    if (ptr.is_const) try writer.writeAll("const ");
    if (ptr.is_volatile) try writer.writeAll("volatile ");
    if (ptr.is_allowzero) try writer.writeAll("allowzero ");

    try writeZigType(writer, ptr.child, exports_decl);
}

inline fn exportFieldNameForType(
    comptime exports_decl: anytype,
    comptime T: type,
) ?[]const u8 {
    const info = @typeInfo(@TypeOf(exports_decl));
    if (info != .@"struct") return null;
    inline for (info.@"struct".fields) |field| {
        const field_type = @field(exports_decl, field.name);
        if (field_type == T) return field.name;
    }
    return null;
}

inline fn isSliceType(comptime T: type) bool {
    return switch (@typeInfo(T)) {
        .pointer => |ptr_info| ptr_info.size == .slice,
        else => false,
    };
}

inline fn slicePointerInfo(comptime slice_type: type) builtin.Type.Pointer {
    const info = @typeInfo(slice_type);
    if (info != .pointer or info.pointer.size != .slice) {
        @compileError("expected slice type, got " ++ @typeName(slice_type));
    }
    return info.pointer;
}

inline fn slicePointerType(comptime slice_type: type) type {
    const info = slicePointerInfo(slice_type);
    return @Type(.{ .pointer = .{
        .size = .many,
        .is_const = info.is_const,
        .is_volatile = info.is_volatile,
        .alignment = info.alignment,
        .address_space = info.address_space,
        .child = info.child,
        .is_allowzero = info.is_allowzero,
        .sentinel_ptr = null,
    } });
}

inline fn paramIsSlice(comptime param: types.FunctionParam) bool {
    return isSliceType(param.original_type);
}

inline fn emitParameterSignature(
    writer: anytype,
    comptime sig: types.FunctionSignature,
    start_idx: usize,
    comptime exports_decl: anytype,
) !void {
    inline for (sig.params, 0..) |param, idx| {
        if (idx < start_idx) continue;
        if (paramIsSlice(param)) {
            try writer.print(", {s}_ptr: usize, {s}_len: usize", .{ param.name, param.name });
        } else {
            try writer.print(", {s}: ", .{param.name});
            try writeZigType(writer, param.original_type, exports_decl);
        }
    }
}

inline fn emitSliceParamReconstruction(
    writer: anytype,
    comptime sig: types.FunctionSignature,
    start_idx: usize,
    comptime exports_decl: anytype,
) !void {
    inline for (sig.params, 0..) |param, idx| {
        if (idx < start_idx) continue;
        if (!paramIsSlice(param)) continue;

        try writer.print("    const {s}_ptr_typed = @as(", .{param.name});
        try writeZigType(writer, slicePointerType(param.original_type), exports_decl);
        try writer.print(", @ptrFromInt({s}_ptr));\n", .{param.name});
        try writer.print("    const {s}: ", .{param.name});
        try writeZigType(writer, param.original_type, exports_decl);
        try writer.print(" = {s}_ptr_typed[0..{s}_len];\n", .{ param.name, param.name });
    }
}

fn methodSelfOffset(comptime sig: types.FunctionSignature, comptime struct_type: type) usize {
    if (sig.params.len == 0) return 0;
    const first = sig.params[0].original_type;
    return switch (@typeInfo(first)) {
        .pointer => |ptr_info| blk: {
            if (@typeName(ptr_info.child) == @typeName(struct_type)) break :blk 1;
            break :blk 0;
        },
        else => 0,
    };
}
